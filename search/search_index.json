{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Get Started Reference"},{"location":"#fast","title":"\u26a1Fast","text":"<p>Parallelizer is optimized for large-scale tasks and fast serialization in mind.</p>"},{"location":"#lightweight","title":"\ud83e\udeb6Lightweight","text":"<p>With no added dependencies, Parallelizer prioritizes simplicity and efficiency.</p>"},{"location":"#performant","title":"\u2728Performant","text":"<p>Designed with minimal footprint, Parallelizer uses only the necessary resources, minimizing additional overhead.</p>"},{"location":"api/","title":"Parallelizer","text":"<p>Contains constructor methods to instantiate classes</p>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#datatype","title":"<code>DataType</code>","text":"<ul> <li><code>{[DataType]: {DataType | string}}</code> Contains all the supported DataTypes for packet definitions</li> </ul>"},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#listentotask","title":"<code>ListenToTask</code>","text":"<p>Creates 3 new message binds to the actor, one will caches the packet type definitions, the other will cache the local memory, this will not be bound if <code>cacheLocalMemory</code> is <code>false</code>. The last one will process the actual task, which has a middleware that will serialize the return values of the callback and batch them accordingly.</p> <p>Parameters</p> <ul> <li> <p>actor: <code>Actor</code></p> </li> <li> <p>taskName: <code>string</code> </p> </li> <li> <p>callback:<code>(taskId: number, memory: SharedTable?, ...Types.SharedTableValues) -&gt; {Types.SerializableValues}</code></p> </li> <li>cacheLocalMemory: <code>boolean</code></li> </ul> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/#createtaskcoordinator","title":"<code>CreateTaskCoordinator</code>","text":"<p>Create a new population of actors. The number of actors should ideally be a power of 2, refer to Multithreading Best Practices to determine the right number of actors.</p> <p>Parameters</p> <ul> <li>workerScript: <code>Script | LocalScript</code></li> <li>actorStorage: <code>Instance</code></li> <li>actorCount: <code>number</code></li> </ul> <p>Returns</p> <ul> <li><code>TaskCoordinator</code></li> </ul>"},{"location":"api/datatypes/","title":"Data Types","text":"<p>A list of supported serializable data types</p>"},{"location":"api/datatypes/#u8","title":"u8","text":"<p>Occupies 1 byte, short for unsigned 8 bit integer (uint8)</p>"},{"location":"api/datatypes/#u16","title":"u16","text":"<p>Occupies 2 bytes, short for unsigned 16 bit integer (uint16)</p>"},{"location":"api/datatypes/#u32","title":"u32","text":"<p>Occupies 4 bytes, short for unsigned 32 bit integer (uint32)</p>"},{"location":"api/datatypes/#i8","title":"i8","text":"<p>Occupies 1 byte, short for signed 8 bit integer (int8)</p>"},{"location":"api/datatypes/#i16","title":"i16","text":"<p>Occupies 2 bytes, short for signed 16 bit integer (int16)</p>"},{"location":"api/datatypes/#i32","title":"i32","text":"<p>Occupies 4 bytes, short for signed 32 bit integer (int32)</p>"},{"location":"api/datatypes/#f32","title":"f32","text":"<p>Occupies 4 bytes, short for 32 bit floating point number</p>"},{"location":"api/datatypes/#f64","title":"f64","text":"<p>Occupies 8 bytes, short for 64 bit floating point number</p>"},{"location":"api/datatypes/#bool","title":"bool","text":"<p>Occupies 1 byte, serializes as a <code>u8</code> (1 or 0)</p>"},{"location":"api/datatypes/#strlen","title":"str(len)","text":"<p>Occupies <code>len+4</code> bytes, 4 extra bytes for storing the length (u32) </p>"},{"location":"api/datatypes/#vector3","title":"vector3","text":"<p>Occupies 24 bytes, 8 bytes for each axis (XYZ)</p>"},{"location":"api/datatypes/#vector3i16","title":"vector3i16","text":"<p>Occupies 6 bytes, 2 bytes for each axis (XYZ). Short for vector3int16</p>"},{"location":"api/datatypes/#vector2","title":"vector2","text":"<p>Occupies 16 bytes, 8 byte for each axis (XY)</p>"},{"location":"api/datatypes/#vector2i16","title":"vector2i16","text":"<p>Occupies 24 bytes, 2 byte for each axis (XY). Short for vector2int16</p>"},{"location":"api/datatypes/#cframe","title":"cframe","text":"<p>Occupies 48 bytes, 24 bytes for XYZ positional components, another 24 bytes for XYZ rotational components</p>"},{"location":"api/datatypes/#cframef32-experimental","title":"cframef32 EXPERIMENTAL","text":"<p>Occupies 24 bytes, 16 bytes for XYZ positional components, another 16 bytes for XYZ rotational components</p>"},{"location":"api/datatypes/#cframe18-experimental","title":"cframe18 EXPERIMENTAL","text":"<p>Occupies 18 bytes, 12 bytes for XYZ positional components, 6 bytes for XYZ rotational components (<code>4.8 * 10^-5</code> radians or <code>2.75 * 10^-3</code> degrees of precision loss at most)</p>"},{"location":"api/datatypes/#color3","title":"color3","text":"<p>Occupies 3 bytes, 1 byte for each channel</p>"},{"location":"api/datatypes/#color3b16","title":"color3b16","text":"<p>Occupies 2 bytes. 5 bits for red, 6 bits for green, 5 bits for blue. Short for color3bit16. This takes a bit longer to serialize than Color3</p>"},{"location":"api/datatypes/#bufferlen","title":"buffer(len)","text":"<p>Occupies <code>len+2</code> bytes. 2 extra bytes to store the buffer length (u16). This takes a bit longer to serialize</p>"},{"location":"api/task-coordinator/","title":"Task Coordinator","text":"<p>Manages handling of thread dispatches, caching, and serialization/deserialization</p>"},{"location":"api/task-coordinator/#properties","title":"Properties","text":""},{"location":"api/task-coordinator/#actors","title":"<code>actors</code>","text":"<ul> <li><code>{Actor}</code> A list of actors, each with its own worker script</li> </ul>"},{"location":"api/task-coordinator/#actorcount","title":"<code>actorCount</code>","text":"<ul> <li><code>number</code> How many actors in the actor pool</li> </ul>"},{"location":"api/task-coordinator/#connections","title":"<code>connections</code>","text":"<ul> <li><code>{RBXScriptConnection}</code> A list of PreSimulation connections</li> </ul>"},{"location":"api/task-coordinator/#methods","title":"Methods","text":""},{"location":"api/task-coordinator/#definetask","title":"<code>DefineTask</code>","text":"<p>Warning</p> <p>The <code>taskName</code> can't end with <code>-parallelizer-internal-def</code> nor <code>-parallelizer-internal-mem</code> as they are reserved for internal use</p> <p>Sends the serialized type definition and local memory specified under the message <code>taskName-parallelizer-internal-def</code> and <code>taskName-parallelizer-internal-mem</code> respectively</p> <p>Parameters</p> <ul> <li>taskName: <code>string</code></li> <li>taskMetaData: <code>Types.TaskMetaData</code></li> </ul> <p>Returns</p> <ul> <li><code>Task</code></li> </ul>"},{"location":"api/task-coordinator/#dispatchtaskequally","title":"<code>DispatchTaskEqually</code>","text":"<p>A proxy to <code>DispatchTask</code>, batchSize will be calculated automatically</p> <p>Parameters</p> <ul> <li>taskObject: <code>Task</code></li> <li>threadCount: <code>number</code></li> <li>callback: <code>(result: {Types.SerializableValues}) -&gt; void</code></li> <li>useMergedBuffer: <code>boolean?</code></li> <li>...: <code>Types.SharedTableValues</code></li> </ul> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/task-coordinator/#dispatchtask","title":"<code>DispatchTask</code>","text":"<p>Creates a PreSimulation connection to deserialize the packets and dispatches the appropriate actors to the task. The callback will be called once the packets are gathered together. You can also choose to return the merged buffer instead of a table.</p> <p>Parameters</p> <ul> <li>taskObject: <code>Task</code></li> <li>threadCount: <code>number</code></li> <li>batchSize: <code>number</code></li> <li>callback: <code>(result: {Types.SerializableValues}) -&gt; void</code></li> <li>useMergedBuffer: <code>boolean?</code></li> <li>...: <code>Types.SharedTableValues</code></li> </ul> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/task-coordinator/#destroy","title":"<code>Destroy</code>","text":"<p>Disposes the ongoing dispatch connections and the actors</p> <p>Parameters</p> <p>Returns</p> <ul> <li><code>void</code></li> </ul>"},{"location":"api/types/","title":"Types","text":""},{"location":"api/types/#serializablevalues","title":"<code>SerializableValues</code>","text":"<pre><code>number | boolean | string | Vector3 | Vector3int16 | Vector2 | Vector2int16 | CFrame | Color3 | buffer\n</code></pre>"},{"location":"api/types/#sharedtablevalues","title":"<code>SharedTableValues</code>","text":"<pre><code>Vector2 | Vector3 | CFrame | Color3 | UDim | UDim2 | number | boolean | buffer\n</code></pre>"},{"location":"api/types/#datatype","title":"<code>DataType</code>","text":"<pre><code>export type DataType = 'u8' | 'u16' | 'u32' | 'i8' | 'i16' | 'i32' | 'f32' | 'f64' | 'bool' | 'str' | 'cframe' | 'v3' | 'v3i16' | 'v2' | 'v2i16' | 'color3' | 'color3b16' | 'buffer'\n</code></pre>"},{"location":"api/types/#packetdefinition","title":"<code>PacketDefinition</code>","text":"<pre><code>{ {DataType | string} }\n</code></pre>"},{"location":"api/types/#taskmetadata","title":"<code>TaskMetaData</code>","text":"<pre><code>{ \n    packet: PacketDefinition;\n    localMemory: SharedTable\n}\n</code></pre>"},{"location":"api/types/#task","title":"<code>Task</code>","text":"<pre><code>{\n    taskName: string;\n    packetDef: PacketDefinition;\n    packetBytesNeeded: number\n}\n</code></pre>"},{"location":"api/types/#taskcoordinator","title":"<code>TaskCoordinator</code>","text":"<pre><code>{\n    actors: {Actor};\n    actorCount: number;\n    connections: {RBXScriptConnection};\n\n    DefineTask: (\n        self: TaskCoordinator, \n        taskName: string, \n        taskMetaData: TaskMetaData\n    ) -&gt; Task;\n\n    DispatchTask: (\n        self: TaskCoordinator, \n        taskObject: Task, \n        threadCount: number, \n        batchSize: number,\n        callback: (any) -&gt; (), \n        returnMergedRawBuffer: boolean?,\n        ...SharedTableValues\n    ) -&gt; ();\n\n    DispatchTaskEqually: (\n        self: TaskCoordinator, \n        taskObject: Task, \n        threadCount: number, \n        callback: (any) -&gt; (), \n        returnMergedRawBuffer: boolean?,\n        ...SharedTableValues\n    ) -&gt; ()\n\n    Destroy: (self: TaskCoordinator) -&gt; ();\n}\n</code></pre>"},{"location":"extras/philosophy/","title":"Philosophy","text":"<p>Parallelism in computing means breaking tasks into smaller pieces so they can be done at the same time, making computers much faster. This module was designed to make parallelism easier and more effective for everyone. It's built to help developers achieve top performance while being simple to use. It focuses on speed, scalability, ease of use, and giving developers the freedom to work their way.</p> <ol> <li>Performance     At its core, this module prioritizes speed without excessive compromise on memory usage. By employing a buffer-based approach, data is serialized into buffers before being stored in a SharedTable. This method should reduce latency and ensures efficient data transfer, particularly in scenarios requiring large chunks of data to move seamlessly between parallel and serial tasks \u2014 a critical use case where the module shines.</li> <li>Simplicity &amp; Flexibility     While performance is essential, it should never come at the cost of usability. This module is designed to abstract the complexities of parallel processing. Modular by design, it gives developers the flexibility to implement custom task-handling logic to fit their specific needs, making it robust and extensible.</li> <li>Scalability     Scalability ensures this module can handle everything from small tasks to massive tasks without slowing down considerably. By leveraging actors, it keeps operations fast regardless of workload size. This means the module grows with your needs and won't limit your ambitions.</li> </ol>"},{"location":"guides/quick-start/getting-started/","title":"Getting Started","text":"<p>If you haven't already, refer to Installation</p>"},{"location":"guides/quick-start/getting-started/#what-is-a-task-coordinator","title":"What is a Task Coordinator?","text":"<p>A Task Coordinator is responsible for handling the dispatch of tasks, and managing the deserialization of tasks to be sent back to the main script. You can create a Task Coordinator using <code>Parallelizer.CreateTaskCoordinator</code> init.server.luau<pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\nlocal TaskCoordinator = Parallelizer.CreateTaskCoordinator(script.Worker, script, 256)\n</code></pre></p> <p>Actor count does NOT mean the number of cores to use</p> <p>Roblox will automatically spread the actor workload into the underlying hardware. So if you're targeting 4-core systems, that doesn't mean you should only use 4 actors, higher actor count may lead to better performance, but you should balance out the actor count to be around 64-256.</p>"},{"location":"guides/quick-start/getting-started/#creating-a-task","title":"Creating a Task","text":"<p>A task can be created using <code>TaskCoordinator:DefineTask</code>. It contains the type definitions of what each task should return, which is used for serialization/deserialization purposes init.server.luau<pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\nlocal TaskCoordinator = Parallelizer.CreateTaskCoordinator(script.Worker, script, 256)\n\nlocal DataType = Parallelizer.DataType -- For easy access\n\nlocal TestTask = TaskCoordinator:DefineTask('Test', {\n    packet = {\n        DataType.u16, DataType.str(11) -- String requires a fixed length, the worker task should return a string which should not be less or more than the length specified\n    };\n    localMemory = SharedTable.new({'Hello World'}) -- 'Hello World' is exactly 11 characters long, including the whitespace\n})\n</code></pre></p>"},{"location":"guides/quick-start/getting-started/#creating-the-worker-script","title":"Creating the worker script","text":"<p>The worker script is responsible for running parallel tasks dispatched by the Task Coordinator, a worker script may have more than 1 unique tasks connected. The worker script can run the same task more than once if the thread count is higher than the actor count. To connect to a task, you can use <code>Parallelizer.ListenToTask</code> worker.server.luau<pre><code>local Actor = script:GetActor()\nif not Actor then return end\n\nlocal Parallelizer = require(game.ReplicatedStorage.Parallelizer)\n\nParallelizer.ListenToTask(Actor, 'Test', function(taskId, localMemory)\n    return {2^taskId, localMemory[1]} -- localMemory[1] is 'Hello World'\nend, true) -- true specifies that it should load and store the localMemory\n</code></pre></p>"},{"location":"guides/quick-start/getting-started/#dispatching-the-task","title":"Dispatching the task","text":"<p>To dispatch a task, you can use <code>TaskCoordinator:DispatchTask</code> or <code>TaskCoordinator:DispatchTaskEqually</code>. Difference between the two are, <code>DispatchTask</code> expects a batchSize, while <code>DispatchTaskEqually</code> calculates the batchSize for you init.server.luau<pre><code>local Parallelizer = require(game.ReplicatedStorage.Parallelizer)\nlocal TaskCoordinator = Parallelizer.CreateTaskCoordinator(script.Worker, script, 256)\n\nlocal DataType = Parallelizer.DataType -- For easy access\n\nlocal TestTask = TaskCoordinator:DefineTask('Test', {\n    packet = {\n        DataType.u16, DataType.str(11) -- String requires a fixed length, the task worker should return a string which should not be less or more than the length specified\n    };\n    localMemory = SharedTable.new({'Hello World'}) -- 'Hello World' is exactly 11 characters long, including the whitespace\n})\n\nTaskCoordinator:DispatchTask(TestTask, 1024, 8, function(result: {number, string}) -- 8 task per actor\n    print(result) -- An array containing the results of the task\nend)\n</code></pre></p> <p>Tip</p> <p>To maximize performance, set the SignalBehavior to Immediate in Workspace properties</p>"},{"location":"guides/quick-start/installation/","title":"Installation","text":""},{"location":"guides/quick-start/installation/#wally","title":"Wally","text":"<ol> <li>Add Parallelizer to your <code>wally.toml</code> wally.toml<pre><code>[dependencies]\nparallelizer = \"artzified/parallelizer@2.0.0\"\n</code></pre></li> <li>Run <code>wally install</code></li> </ol>"},{"location":"guides/quick-start/installation/#github","title":"Github","text":"<ol> <li>Get the latest release here</li> <li>Drag and drop the rbxm file to studio</li> <li>Place the module in <code>ReplicatedStorage</code></li> </ol>"},{"location":"guides/tips/choosing-actor-count/","title":"Choosing the right actor count","text":"<p>THIS PAGE IS UNDER CONSTRUCTION</p>"},{"location":"guides/tips/derive-taskid/","title":"Deriving Data from TaskId","text":"<p>Sending data from serial to parallel is often costly. To optimize performance, we aim to send the smallest possible amount of data. One technique is to leverage taskId to derive other information without transmitting it explicitly.</p> <p>This page will guide you through deriving various kinds of information with minimal data transmission</p>"},{"location":"guides/tips/derive-taskid/#x-and-y-from-taskid","title":"X and Y from <code>taskId</code>","text":"<p>Given a grid or matrix, you can calculate the X and Y positions from the taskId and width of the grid.</p> <p><pre><code>local function getXYFromTaskId(taskId: number, width: number)\n    return taskId % width, taskId // width -- x, y\nend\n</code></pre> Example usage: worker.server.luau<pre><code>Parallelizer.ListenToTask(Actor, 'XY', function(taskId: number, localMemory: SharedTable) \n    local x, y = GetXYFromTaskId(taskId, localMemory[1]) -- Assuming the width is stored in the local memory\n\n    -- ... do something\nend)\n</code></pre></p> <p>Info</p> <p>For this to work, the thread count dispatched needs to be equal to <code>width * height</code></p>"}]}